<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body style="margin: 0; height: 100dvh">
    <canvas style="width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated;" />
    <script type="module">
        const GRID_WIDTH = 64;
        const GRID_HEIGHT = 64;

        const canvas = document.querySelector('canvas');
        canvas.width = 512;
        canvas.height = 512;
        console.log(canvas);

        const ctx = canvas.getContext('webgpu');
        console.log(ctx);

        if (!navigator.gpu) {
            throw new Error("WebGPU not supported on this browser.");
        }

        const adapter = await navigator.gpu.requestAdapter();
        console.log(adapter);

        if (!adapter) {
            throw new Error("No appropriate GPUAdapter found.");
        }

        const device = await adapter.requestDevice();
        console.log(device);
        
        const format = navigator.gpu.getPreferredCanvasFormat();
        console.log(format);
        
        ctx.configure({ device, format });

        const vertices = new Float32Array([
            // Triangle 1
            -0.8, 0.8,
            0.8, 0.8,
            -0.8, -0.8,
            // Triangle 2
            -0.8, -0.8,
            0.8, 0.8,
            0.8, -0.8,
        ]);
        const vertexBuffer = device.createBuffer({
            label: 'Cell vertices',
            size: vertices.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(vertexBuffer, 0, vertices);

        const uniform = new Float32Array([GRID_WIDTH, GRID_HEIGHT]);
        const uniformBuffer = device.createBuffer({
            label: 'Grid Uniforms',
            size: uniform.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(uniformBuffer, 0, uniform);

        const shader = device.createShaderModule({
            label: 'Cell shader',
            code: `
                @group(0) @binding(0) var<uniform> grid: vec2f;

                struct Input {
                    @location(0) position: vec2f,
                    @builtin(instance_index) instance: u32
                }

                struct Output {
                    @builtin(position) position: vec4f,
                    @location(0) cell: vec2f,
                    @location(1) state: f32,
                }

                @vertex
                fn vertex (input: Input) -> Output {
                    var out: Output;
                    let n = f32(input.instance);
                    let cell = vec2f(n % grid.x, floor(n / grid.y));
                    let unit = vec2f(2 / grid); // -1 <-> 1 = 2

                    out.position = vec4f((input.position + 1) / grid - 1 + (cell * unit), 0, 1);
                    out.cell = cell;
                    out.state = 1.0f;

                    return out;
                }

                @fragment
                fn fragment (out: Output) -> @location(0) vec4f {
                    return vec4f(
                        out.cell.x / grid.x,
                        out.cell.y / grid.y,
                        1 - out.cell.x / grid.x,
                        1,
                    );
                }
            `,
        });
        const pipeline = device.createRenderPipeline({
            label: 'Cell pipeline',
            layout: 'auto',
            vertex: {
                module: shader,
                entryPoint: 'vertex',
                buffers: [{
                    arrayStride: 8,
                    attributes: [{
                        format: 'float32x2',
                        offset: 0,
                        shaderLocation: 0,
                    }],
                }],
            },
            fragment: {
                module: shader,
                entryPoint: 'fragment',
                targets: [{
                    format,
                }],
            },
        });
        const group = device.createBindGroup({
            label: 'Cell bind group',
            layout: pipeline.getBindGroupLayout(0),
            entries: [{
                binding: 0,
                resource: {
                    buffer: uniformBuffer,
                },
            }],
        });

        const encoder = device.createCommandEncoder();
        console.log(encoder);

        const pass = encoder.beginRenderPass({
            colorAttachments: [{
                view: ctx.getCurrentTexture().createView(),
                loadOp: 'clear',
                clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1 },
                storeOp: 'store',
            }],
        });
        pass.setPipeline(pipeline);
        pass.setVertexBuffer(0, vertexBuffer);
        pass.setBindGroup(0, group);
        pass.draw(vertices.length / 2, GRID_WIDTH * GRID_HEIGHT); // 2D with no additional attribute
        pass.end();

        device.queue.submit([encoder.finish()]);
    </script>
</body>
</html>