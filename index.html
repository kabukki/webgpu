<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>
</head>
<body style="margin: 0; height: 100dvh; background: black">
    <canvas style="width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated;" />
    <script type="module">
        const GRID_WIDTH = 64;
        const GRID_HEIGHT = 64;
        const WORKGROUP_SIZE = 8;

        const stats = new Stats();
        document.body.appendChild(stats.dom);

        const canvas = document.querySelector('canvas');
        canvas.width = 512;
        canvas.height = 512;
        console.log(canvas);

        const ctx = canvas.getContext('webgpu');
        console.log(ctx);

        if (!navigator.gpu) {
            throw new Error("WebGPU not supported on this browser.");
        }

        const adapter = await navigator.gpu.requestAdapter();
        console.log(adapter);

        if (!adapter) {
            throw new Error("No appropriate GPUAdapter found.");
        }

        const device = await adapter.requestDevice();
        console.log(device);
        
        const format = navigator.gpu.getPreferredCanvasFormat();
        console.log(format);
        
        ctx.configure({ device, format });

        const vertices = new Float32Array([
            // Triangle 1
            -0.8, 0.8,
            0.8, 0.8,
            -0.8, -0.8,
            // Triangle 2
            -0.8, -0.8,
            0.8, 0.8,
            0.8, -0.8,
        ]);
        const vertexBuffer = device.createBuffer({
            label: 'Cell vertices',
            size: vertices.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(vertexBuffer, 0, vertices);

        const uniform = new Float32Array([GRID_WIDTH, GRID_HEIGHT]);
        const uniformBuffer = device.createBuffer({
            label: 'Grid uniforms',
            size: uniform.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(uniformBuffer, 0, uniform);

        const state = Uint32Array.from({ length: GRID_WIDTH * GRID_HEIGHT }, () => Math.random() > 0.8 ? 1 : 0);
        const stateBuffer = [
            device.createBuffer({
                label: 'Cell state A',
                size: state.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            }),
            device.createBuffer({
                label: 'Cell state B',
                size: state.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            }),
        ];
        device.queue.writeBuffer(stateBuffer[0], 0, state);

        const shader = device.createShaderModule({
            label: 'Cell shader',
            code: `
                @group(0) @binding(0) var<uniform> grid: vec2f;
                @group(0) @binding(1) var<storage> state: array<u32>;

                struct Input {
                    @location(0) position: vec2f,
                    @builtin(instance_index) instance: u32
                }

                struct Output {
                    @builtin(position) position: vec4f,
                    @location(0) cell: vec2f,
                    @location(1) state: f32,
                }

                @vertex
                fn vertex (input: Input) -> Output {
                    var out: Output;
                    let n = f32(input.instance);
                    let cell = vec2f(n % grid.x, floor(n / grid.y));
                    let unit = vec2f(2 / grid); // -1 <-> 1 = 2

                    out.position = vec4f((input.position + 1) / grid - 1 + (cell * unit), 0, 1);
                    out.cell = cell;
                    out.state = f32(state[input.instance]);

                    return out;
                }

                @fragment
                fn fragment (out: Output) -> @location(0) vec4f {
                    if (out.state == 0) {
                        discard;
                    }

                    return vec4f(
                        out.cell.x / grid.x,
                        out.cell.y / grid.y,
                        1 - out.cell.x / grid.x,
                        1,
                    );
                }
            `,
        });
        const simulation = device.createShaderModule({
            label: 'Cell shader',
            code: `
                @group(0) @binding(0) var<uniform> grid: vec2f;
                @group(0) @binding(1) var<storage, read> stateIn: array<u32>;
                @group(0) @binding(2) var<storage, read_write> stateOut: array<u32>;

                fn toLinear (cell: vec2u) -> u32 {
                    return (cell.x % u32(grid.x)) + (cell.y % u32(grid.y)) * u32(grid.x);
                }

                fn isActive (cell: vec2u) -> u32 {
                    return stateIn[toLinear(cell)];
                }

                @compute
                @workgroup_size(${WORKGROUP_SIZE}, ${WORKGROUP_SIZE})
                fn compute (@builtin(global_invocation_id) cell: vec3u) {
                    let n = toLinear(cell.xy);
                    let neighbours = isActive(vec2(cell.x - 1, cell.y - 1))
                                    + isActive(vec2(cell.x, cell.y - 1))
                                    + isActive(vec2(cell.x + 1, cell.y - 1))
                                    + isActive(vec2(cell.x - 1, cell.y))
                                    + isActive(vec2(cell.x + 1, cell.y))
                                    + isActive(vec2(cell.x - 1, cell.y + 1))
                                    + isActive(vec2(cell.x, cell.y + 1))
                                    + isActive(vec2(cell.x + 1, cell.y + 1));
                    var out = stateIn[n];

                    if (neighbours < 2 || neighbours > 3) {
                        out = 0;
                    } else if (neighbours == 3) {
                        out = 1; 
                    }

                    stateOut[n] = out;
                }
            `,
        });

        const bindGroupLayout = device.createBindGroupLayout({
            label: 'Cell bind group layout',
            entries: [{
                binding: 0,
                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,
                buffer: { type: 'uniform' }, // Grid uniform buffer
            }, {
                binding: 1,
                visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
                buffer: { type: 'read-only-storage' }, // Cell state input buffer
            }, {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'storage' }, // Cell state output buffer
            }],
        });
        const groups = [
            device.createBindGroup({
                label: 'Cell bind group A',
                layout: bindGroupLayout,
                entries: [{
                    binding: 0,
                    resource: {
                        buffer: uniformBuffer,
                    },
                }, {
                    binding: 1,
                    resource: {
                        buffer: stateBuffer[0],
                    },
                }, {
                    binding: 2,
                    resource: {
                        buffer: stateBuffer[1],
                    },
                }],
            }),
            device.createBindGroup({
                label: 'Cell bind group B',
                layout: bindGroupLayout,
                entries: [{
                    binding: 0,
                    resource: {
                        buffer: uniformBuffer,
                    },
                }, {
                    binding: 1,
                    resource: {
                        buffer: stateBuffer[1],
                    },
                }, {
                    binding: 2,
                    resource: {
                        buffer: stateBuffer[0],
                    },
                }],
            }),
        ];

        const pipelineLayout = device.createPipelineLayout({
            label: 'Cell pipeline layout',
            bindGroupLayouts: [bindGroupLayout],
        });
        const renderPipeline = device.createRenderPipeline({
            label: 'Render pipeline',
            layout: pipelineLayout,
            vertex: {
                module: shader,
                entryPoint: 'vertex',
                buffers: [{
                    arrayStride: 8,
                    attributes: [{
                        format: 'float32x2',
                        offset: 0,
                        shaderLocation: 0,
                    }],
                }],
            },
            fragment: {
                module: shader,
                entryPoint: 'fragment',
                targets: [{
                    format,
                }],
            },
        });
        const computePipeline = device.createComputePipeline({
            label: 'Compute pipeline',
            layout: pipelineLayout,
            compute: {
                module: simulation,
                entryPoint: 'compute',
            },
        });

        let cycle = 0;

        function callback (...t) {
            stats.begin();

            const encoder = device.createCommandEncoder();
            const compute = encoder.beginComputePass();
            compute.setPipeline(computePipeline);
            compute.setBindGroup(0, groups[cycle % 2]); // in <-> out
            compute.dispatchWorkgroups(Math.ceil(GRID_WIDTH / WORKGROUP_SIZE), Math.ceil(GRID_HEIGHT / WORKGROUP_SIZE));
            compute.end();

            cycle += 1;
            console.log(`cycle`, cycle);

            const render = encoder.beginRenderPass({
                colorAttachments: [{
                    view: ctx.getCurrentTexture().createView(),
                    loadOp: 'clear',
                    clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1 },
                    storeOp: 'store',
                }],
            });
            render.setPipeline(renderPipeline);
            render.setBindGroup(0, groups[cycle % 2]); // compute's `out` becomes render's `in`
            render.setVertexBuffer(0, vertexBuffer);
            render.draw(vertices.length / 2, GRID_WIDTH * GRID_HEIGHT); // 2D with no additional attribute
            render.end();

            device.queue.submit([encoder.finish()]);

            stats.end();

            requestAnimationFrame(callback);
        }

        requestAnimationFrame(callback);
    </script>
</body>
</html>